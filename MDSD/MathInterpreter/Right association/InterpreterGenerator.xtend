/*
 * generated by Xtext 2.13.0
 */
package org.xtext.mathinterpreter.generator
 
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.mathinterpreter.interpreter.MathExp
import org.xtext.mathinterpreter.interpreter.Exp
 
import org.xtext.mathinterpreter.interpreter.Factor
 
import org.xtext.mathinterpreter.interpreter.Parenthesis
import org.xtext.mathinterpreter.interpreter.Primary
import javax.swing.JOptionPane
import org.xtext.mathinterpreter.interpreter.Add
import org.xtext.mathinterpreter.interpreter.Sub
import org.xtext.mathinterpreter.interpreter.Mult
import org.xtext.mathinterpreter.interpreter.Div
 
/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class InterpreterGenerator extends AbstractGenerator {
 
    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val math = resource.allContents.filter(MathExp).next
        val result = math.compute
        System.out.println("Math expression = "+math.display)
        JOptionPane.showMessageDialog(null, "result = "+result,"Math Language", JOptionPane.INFORMATION_MESSAGE)
    }
   
        def double compute(MathExp math) {
        math.exp.computeExp
    }
   
    def double computeExp(Exp exp) {
        val left = exp.left.computeFactor
        switch exp.operator {
            case exp.operator instanceof Add: left+exp.right.computeExp
            case exp.operator instanceof Sub: left-exp.right.computeExp
            default: left
        }
    }
   
    def double computeFactor(Factor fact){
        val p = fact.p.computePrim
        switch fact.operator{
            case fact.operator instanceof Mult: p*fact.f.computeFactor
            case fact.operator instanceof Div:  (p/fact.f.computeFactor).doubleValue()
            default: p
        }
    }
   
    def double computePrim(Primary prim) {
        switch prim {
            case prim.par !== null: prim.par.exp.computeExp
            default: prim.num.value
        }
    }
   
    def CharSequence display(MathExp math) '''Math[«math.exp.displayExp»]'''
    def CharSequence displayExp(Exp exp) '''Exp[«exp.left.displayFactor»«exp.operator?.displayOp»«exp.right?.displayExp»]'''
    def dispatch String displayOp(Add op)  { "+" }
    def dispatch String displayOp(Sub op) { "-" }
    def dispatch String displayOp(Mult op) { "*" }
    def dispatch String displayOp(Div op) { "/" }
    def CharSequence displayFactor(Factor fact) '''Factor[«fact.p.displayPrimary»«fact.operator?.displayOp»«fact.f?.displayFactor»]'''
    def CharSequence displayPrimary(Primary prim) '''«prim.num?.value»«prim.par?.exp?.displayExp»'''
}